Silicon {
Program   = SourceElement*

SourceElement =
				| STATEMENT --sourceStatement
				| EXP ";" --sourceExp
STATEMENT = singleLineComment | multiLineComment

Keyword = "@" identifier
		
EXP = 
		// covers @type defs, @func defs and @name/@let defs
		// Anonymous Types and functions make sense
		// Anonymous variable? @let = 3 * 3;
		// @let _ = 3 * 3;
		| Keyword TypedIdentifier? Args Assign? --Def
		| "@when" Args --whenDef
		| "@open" Args --import
		| "\\" Args Assign --lambda
		| EXP BinOp EXP --compare
		| EXP OpKeyword EXP --binOpKeywordExp
		| EXP (operator) EXP  --binOpExp
		| EXP "<=" EXP --lteEXP
		| "#" Args ("=>" identifier)+ --pipeExp
		| "#" (identifier | EXP) ("." identifier)+ --methodChainExp
		| identifier ("." identifier)+ --namespace
		| TypedIdentifier
		| identifier
		| "0b" bit+ ("_" bit+)* --bin
		| "0x" hexDigit+ ("_" hexDigit+)* --hex
		| "0c" octDigit+ ("_" octDigit+)* --oct
		| digit+ ("_" digit+)* "." digit+ --float
		| digit+ ("_" digit+)* --int
		| "\"" stringChar*  "\"" --stringLit
		| "{" (EXP ";")* "}" --block
		| "(" (identifier "=" EXP)* ")" --mapLit
		| "(" EXP* ")" --parens
		| "[" ListOf<EXP,","> "]" --arrayLit
		| "#" identifier Args --fnCall
BinOp =   		| "==" --equal
				| "===" --identical
				| "<>" --notEqual
				| "<=>" --notIdentical
				| "<" --lt
				| ">" --gt
				| "<=" --lte
				| ">=" --gte
OpKeyword =     | "@eq" --eq
				| "@neq" --neq
				| "@is" --is
				| "@and" --and
				| "@or" --or
				| "@not" --not
				| "@b_and" --band
				| "@b_or" --bor
				| "@b_xor" --bxor
				| "@b_not" --bnot
				| "@b_nand" --bnand
				| "@b_nor" --bnor
				| "@b_xnor" --bxnor
				| "@name" TypedIdentifier Args --nameExp
				| "@when" Args -- whenExp 
				| "@loop" Args -- loopExp
				| "@func" Args -- funcExp
				| "@open" Args --import
				| booleanLiteral --booleanLit
octDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
bit = "0" | "1"
operator = "+" | "-" | "*" | "/" | "**" | "++"
stringChar = ~("\"" | "\\" | lineTerminator) any
lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
booleanLiteral = "@true" | "@false"
namespace = identifier ("::" identifier)+
identifier = "_" | letter+
TypedIdentifier = identifier (":" ListOf<(identifier | EXP),",">)*
Args  = ListOf<EXP+, ",">
Assign = "=" EXP
comment = multiLineComment | singleLineComment
sourceCharacter = any
multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
singleLineComment = "//" (~lineTerminator sourceCharacter)*
space := whitespace | lineTerminator | comment
unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
whitespace = "\t"
			| "\x0B"    -- verticalTab
			| "\x0C"    -- formFeed
			| " "
			| "\u00A0"  -- noBreakSpace
			| "\uFEFF"  -- byteOrderMark
			| unicodeSpaceSeparator
}