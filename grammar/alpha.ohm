Silicon {
	// Initial Alpha release grammar to support
	Program   = SourceElement*
	SourceElement = | STATEMENT --sourceStatement | EXP ";" --sourceExp
	STATEMENT = 
			| singleLineComment 
			| multiLineComment
	singleLineComment = "//" (~lineTerminator sourceCharacter)*
	lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
	sourceCharacter = any
	multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
	EXP =   
   			| BinOpExp
			| Definition
			| Parens
			| MethodChainExp
			| FunctionCall
            | InfixExp
			| Literal
            | Property
            | identifier

    Property = identifier ("." identifier)+
	// List<T> becomes List:T 
	// Map<A,B> becomes Map[A,B] 
	// OR I'm thinking more like a function 
	// Map :A,:B 
	// Only difference is that types start with :
	// new Map<String,Int>();
	// #Map :String,Integer
    TypeParams = "[" ListOf<Type,","> "]"
	Type = ":" identifier
    Args  = ListOf<Arg, ",">
    Arg = TypedIdentifier | EXP
    Assign = "=" EXP
	Definition = Keyword TypedIdentifier TypeParams? Args Assign? 
	//TODO break this down into Type
	// TODO possibly allow compile time expressions that evaluate to types
	// Type = (":" ~Property identifier)* 
	// LATER something like
	// TypeExp = ??
	// Type = (":" ~Property TypeEXP)* 
    TypedIdentifier = (Property | identifier) (":" ~Property EXP)*
    discard = "_"
	identifier = discard | alpha+ alnum*
	Keyword = "@" identifier
	InfixExp = EXP InfixFunc EXP 
	BinOpExp = EXP BinOp EXP 
	Parens = "(" EXP* ")" 
	MethodChainExp = evalSigil (identifier | EXP) ("." identifier)+ Args 
	FunctionCall = evalSigil (Property | identifier) ListOf<EXP,","> 
    evalSigil =  comptimeSigil | runtimeSigil
    runtimeSigil = "#"
	Literal = StringLiteral | BlockLiteral | MapLiteral | ArrayTupleLiteral | NumericLiteral | BooleanLiteral
	StringLiteral = "\"" stringChar*  "\"" 
	stringChar = ~("\"" | "\\" | lineTerminator) any
    BlockLiteral = "{" ListOf<EXP,";"> ";"? "}"
    KeyValue = TypedIdentifier Assign?
	// {name:string -> "Nate";}
    MapLiteral = "{" ListOf<MapEntry,";"> "}"
    MapEntry = TypedIdentifier "->" EXP
	ArrayTupleLiteral = "[" ListOf<EXP,","> "]"
	NumericLiteral = | BinLiteral | HexLiteral | OctLiteral | FloatLiteral | IntLiteral
	BinLiteral = "0b" bit+ ("_" bit+)* 
	bit = "0" | "1"
	HexLiteral = "0x" hexDigit+ ("_" hexDigit+)* 
	OctLiteral = "0c" octDigit+ ("_" octDigit+)* 
	octDigit = "0".."7"
	FloatLiteral = digit+ ("_" digit+)* "." digit+ 
	IntLiteral = digit+ ("_" digit+)* 
    BooleanLiteral = "@true" | "@false"
	BinOp =   	
			| "**" --pow 
			| "++" --concat
			| "+" --add
			| "-" --sub
			| "*" --mult 
			| "/" --div
			| "==" --equal
			| "===" --identical
			| "<>" --notEqual
			| "<=>" --notIdentical
			| "<=" --lte
			| ">=" --gte
			| "<" --lt
			| ">" --gt
	booleanLiteral = "@true" | "@false"
	comment = multiLineComment | singleLineComment
	space := whitespace | lineTerminator | comment
	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
	whitespace = "\t"
			| "\x0B"    -- verticalTab
			| "\x0C"    -- formFeed
			| " "
			| "\u00A0"  -- noBreakSpace
			| "\uFEFF"  -- byteOrderMark
			| unicodeSpaceSeparator
}