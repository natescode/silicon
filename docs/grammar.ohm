Silicon {
  Program = Element*
  Element = | Item ";" -- item
  			| DocComment
  Item = 
  		 | Statement
  		 | ExpressionStart
  Statement =	| Assignment
  				| Definition

 DocComment = "##" docChar*
 docChar = ~("\n" | "\r") any

  Assignment = namespace "=" ExpressionStart
  ExpressionStart = | ExpressionStart BinOp ExpressionEnd  --binOp
    				| FunctionCall --functionCall
    				| ExpressionEnd
	BinOp = | ReservedOp (ReservedOp | operatorChar)+ --withReservedOp
    		| operatorChar+
    // Silicon does not define operators with specific semantics, see 'elaboration' in docs/elaboration.md
	ReservedOp =  "&" | "@" | "$" | "." | ":=" | ":" // Sigils cannot be used an operators
	operatorChar = | "=" | "<" | ">" | "!" | "+" | "-" | "*" | "/" | "%" | "^" | "|" | "~" | "?" | "++" | "+" | "-" | "*" | "/"
  FunctionCallSigil = "&" 
  FunctionCallBody = | keyword Args? -- builtinFunctionCall 
					 | namespace Args? -- userFunctionCall
  FunctionCall = FunctionCallSigil FunctionCallBody
  Args = ListOf<ExpressionStart, ",">
  ExpressionEnd = 
			| Literal
			| namespace
			| Block
			| "(" ExpressionStart ")" -- paren
  Assign = "=" ExpressionStart       
  Binding = ":=" ExpressionEnd
  Block = "{" (Item ";")* "}"
  namespace = identifier ("::" identifier)*
  		Literal = | ArrayLiteral | ObjectLiteral | TupleLiteral | stringLiteral | intLiteral | floatLiteral | booleanLiteral
		ArrayLiteral = "$[" ListOf<ExpressionStart,","> "]"
		ObjectLiteral = "${" ListOf<KeyValuePair,","> "}"
		TupleLiteral = "$(" ListOf<ExpressionStart,","> ")"
		KeyValuePair = typedIdentifier "=" ExpressionStart
		stringLiteral = "'" stringChar*  "'"
			stringChar = ~("'" | "\\" | lineTerminator) any
				lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
			intLiteral = 
			| decLiteral --dec
			| binLiteral --bin
			| hexLiteral --hex 
			| octLiteral --oct
			binLiteral = "0b" bit+ ("_" bit+)*
				bit = "0" | "1"
			hexLiteral = "0x" hexDigit+ ("_" hexDigit+)*
			octLiteral = "0c" octDigit+ ("_" octDigit+)*
				octDigit = "0".."7"
			floatLiteral = digit+ ("_" digit+)* "." digit+
			decLiteral = digit+ ("_" digit+)*
		booleanLiteral = "@true" | "@false"
  Definition = keyword typedIdentifier GenericParams? ListOf<ParamLiteral,","> Binding? 
  GenericParams = "[" ListOf<identifier,","> "]"
  ParamLiteral = typedIdentifier | Literal
  Params = typedIdentifier ListOf<typedIdentifier, ",">
  keyword = "@" identifier
  typedIdentifier = identifier type?
  type = ":" identifier
  discard = "_"
  identifier = discard | letter+ 
  comment =  "#" (~lineTerminator any)*
  space := whitespace | lineTerminator | comment
  whitespace = "\t" | "\x0B" | "\x0C" | " " | "\u00A0" | "\uFEFF" | unicodeSpaceSeparator
  unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
}