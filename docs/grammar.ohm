// Grammar for Silicon, a WASM-first programming language
// This grammar is designed to be simple and easy to parse, with no operator precedence.
// It supports basic expressions, function definitions, and function calls.
// Silicon relies on elaboration to define semantics and more complex constructs.
Silicon {
	Program   = Element*
	Element = | ExpressionStart -- Expression
			  | Definition -- Definition
    // Silicon has no operator precedence, Parsing happens left to right instead of right to left
	ExpressionStart = 	
			| ExpressionStart binOp ExpressionEnd -- binaryExpression
			| "@let" typedIdentifier "=" ExpressionStart -- letExpression
            | "&" identifier Params? -- funcCall
			| ExpressionEnd
    ExpressionEnd =  
			| stringLiteral  
			| booleanLiteral 
			| floatLiteral 
			| intLiteral 
			| variable
			| "(" ExpressionStart ")" -- paren
			| ";"
	binOp = ~ReservedOp operatorChar+
	ReservedOp = | "&" | "@" | "$" | "." | ":" | "::"   
	operatorChar = | "=" | "<" | ">" | "!" | "+" | "-" | "*" | "/" | "%" | "^" | "|" | "~" | "?" | "++" | "+" | "-" | "*" | "/"
	Definition =
		| keyword typedIdentifier Params? Assign 
	FunctionCallSigil = "&" 
	FunctionCallBody =
		| keyword Args? -- builtinFunctionCall
		| identifier Args? -- userFunctionCall
	FunctionCall = FunctionCallSigil FunctionCallBody
	Block = "{" ListOf<ExpressionStart,""> "}"
	range = intLiteral binOp_range intLiteral
	Params = ListOf<typedIdentifier,",">
	Args = ListOf<ExpressionStart, ",">
	Assign = "=" ExpressionStart
    keyword = "@" identifier
		variable = identifier
		stringLiteral = "'" stringChar*  "'"
			stringChar = ~("'" | "\\" | lineTerminator) any
				lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
			intLiteral = 
			| decLiteral --dec
			| binLiteral --bin
			| hexLiteral --hex 
			| octLiteral --oct
			binLiteral = "0b" bit+ ("_" bit+)*
				bit = "0" | "1"
			hexLiteral = "0x" hexDigit+ ("_" hexDigit+)*
			octLiteral = "0c" octDigit+ ("_" octDigit+)*
				octDigit = "0".."7"
			floatLiteral = digit+ ("_" digit+)* "." digit+
			decLiteral = digit+ ("_" digit+)*
		booleanLiteral = "@true" | "@false"
		typedIdentifier = identifier type?
		type = ":" identifier
	identifier = 
    	| discard -- discard
    	| letter+ ("_" | alnum)* -- pub
    	| "_" identifier+ -- priv
    	discard = "_"
	space := whitespace | lineTerminator
	whitespace = "\t"
			| "\x0B"    -- verticalTab
			| "\x0C"    -- formFeed
			| " "
			| "\u00A0"  -- noBreakSpace
			| "\uFEFF"  -- byteOrderMark
			| unicodeSpaceSeparator
	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
}