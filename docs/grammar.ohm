Silicon {
  Program = Element*
  Element = Item ";"
  Item = | Statement
  		 | ExpressionStart
  Statement =	| Assignment
  				| Definition
  Assignment = (Definition | binding) "=" ExpressionStart

    				| FunctionCall --functionCall
    				| Definition
    				| ExpressionEnd
	BinOp = | ReservedOp (ReservedOp | operatorChar)+ --withReservedOp
    		| operatorChar+
    // Silicon does not define operators with specific semantics, see 'elaboration' in docs/elaboration.md
	ReservedOp = "#" | "&" | "@" | "$" | "." | ":" // Sigils cannot be used an operators
	operatorChar = | "=" | "<" | ">" | "!" | "+" | "-" | "*" | "/" | "%" | "^" | "|" | "~" | "?" | "++" | "+" | "-" | "*" | "/"
  FunctionCallSigil = "&" 
  FunctionCallBody = | keyword Args? -- builtinFunctionCall 
					 | binding Args? -- userFunctionCall
  FunctionCall = FunctionCallSigil FunctionCallBody
  Args = ListOf<ExpressionStart, ",">
  ExpressionEnd = 
			| Literal
			| binding
			| Block
			| "(" ExpressionStart ")" -- paren
  Assign = "=" ExpressionStart       
  Block = "{" (Item ";")* "}"
  binding = identifier ("::" identifier)*
  		Literal = | ArrayLiteral | ObjectLiteral | TupleLiteral | stringLiteral | intLiteral | floatLiteral | booleanLiteral
		ArrayLiteral = "$[" ListOf<ExpressionStart,","> "]"
		ObjectLiteral = "${" ListOf<KeyValuePair,","> "}"
		TupleLiteral = "$(" ListOf<ExpressionStart,","> ")"
		KeyValuePair = typedIdentifier "=" ExpressionStart
		stringLiteral = "'" stringChar*  "'"
			stringChar = ~("'" | "\\" | lineTerminator) any
				lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
			intLiteral = 
			| decLiteral --dec
			| binLiteral --bin
			| hexLiteral --hex 
			| octLiteral --oct
			binLiteral = "0b" bit+ ("_" bit+)*
				bit = "0" | "1"
			hexLiteral = "0x" hexDigit+ ("_" hexDigit+)*
			octLiteral = "0c" octDigit+ ("_" octDigit+)*
				octDigit = "0".."7"
			floatLiteral = digit+ ("_" digit+)* "." digit+
			decLiteral = digit+ ("_" digit+)*
		booleanLiteral = "@true" | "@false"
  Definition = keyword typedIdentifier GenericParams? (Params | Literal)* 
  GenericParams = "[" ListOf<identifier,","> "]"
  Params = typedIdentifier ListOf<typedIdentifier, ",">
  keyword = "@" identifier
  typedIdentifier = identifier type?
  type = ":" identifier
  identifier = letter+
  space := whitespace | lineTerminator
  whitespace = "\t" | "\x0B" | "\x0C" | " " | "\u00A0" | "\uFEFF" | unicodeSpaceSeparator
  unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
}